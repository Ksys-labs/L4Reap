<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libsigc++: sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacesigc.html">sigc</a> </li>
      <li><a class="el" href="classsigc_1_1slot4.html">slot4</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> </div>
  <div class="headertitle">
<h1>sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__slot.html">Slots</a>]</small>
</h1> </div>
</div>
<div class="contents">
<!-- doxytag: class="sigc::slot4" --><!-- doxytag: inherits="sigc::slot_base" -->
<p>Converts an arbitrary functor to a unified type which is opaque. <a href="#_details">More...</a></p>

<p><code>#include &lt;sigc++/functors/slot.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt;:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="classsigc_1_1slot4__inherit__graph.png" border="0" usemap="#sigc_1_1slot4_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="sigc_1_1slot4_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4_inherit__map" id="sigc_1_1slot4_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4_inherit__map">
<area shape="rect" id="node7" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html" title="Convenience wrapper for the numbered sigc::slot4 template." alt="" coords="5,237,435,267"/><area shape="rect" id="node2" href="classsigc_1_1slot__base.html" title="Base type for slots." alt="" coords="163,83,277,112"/><area shape="rect" id="node4" href="structsigc_1_1functor__base.html" title="A hint to the compiler." alt="" coords="151,5,289,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="classsigc_1_1slot4-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f6b5b11385536c1c199ca29468c638a"></a><!-- doxytag: member="sigc::slot4::result_type" ref="a3f6b5b11385536c1c199ca29468c638a" args="" -->
typedef T_return&#160;</td><td class="memItemRight" valign="bottom"><b>result_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e83a8c2b863d63a3a62c980311c3cd6"></a><!-- doxytag: member="sigc::slot4::arg1_type_" ref="a4e83a8c2b863d63a3a62c980311c3cd6" args="" -->
typedef type_trait&lt; T_arg1 &gt;::take&#160;</td><td class="memItemRight" valign="bottom"><b>arg1_type_</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa40f41b2158ca59ce1e3fd74b6904f4"></a><!-- doxytag: member="sigc::slot4::arg2_type_" ref="afa40f41b2158ca59ce1e3fd74b6904f4" args="" -->
typedef type_trait&lt; T_arg2 &gt;::take&#160;</td><td class="memItemRight" valign="bottom"><b>arg2_type_</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a157a0ea716942080dbabe5baf86f26dc"></a><!-- doxytag: member="sigc::slot4::arg3_type_" ref="a157a0ea716942080dbabe5baf86f26dc" args="" -->
typedef type_trait&lt; T_arg3 &gt;::take&#160;</td><td class="memItemRight" valign="bottom"><b>arg3_type_</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfec1ba21a151b20403967d5eb9e02cf"></a><!-- doxytag: member="sigc::slot4::arg4_type_" ref="abfec1ba21a151b20403967d5eb9e02cf" args="" -->
typedef type_trait&lt; T_arg4 &gt;::take&#160;</td><td class="memItemRight" valign="bottom"><b>arg4_type_</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T_return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot4.html#a8d7a64f3e5c308136ea6456450d83f43">operator()</a> (arg1_type_ _A_a1, arg2_type_ _A_a2, arg3_type_ _A_a3, arg4_type_ _A_a4) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the contained functor unless slot is in blocking state. <a href="#a8d7a64f3e5c308136ea6456450d83f43"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot4.html#ae88657b620af0e8fa9b4855ecb4f0c20">slot4</a> (const T_functor&amp; _A_func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a slot from an arbitrary functor. <a href="#ae88657b620af0e8fa9b4855ecb4f0c20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b7080168e769cdec8d916f71fa58d21"></a><!-- doxytag: member="sigc::slot4::slot4" ref="a7b7080168e769cdec8d916f71fa58d21" args="(const slot4 &amp;src)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>slot4</b> (const <a class="el" href="classsigc_1_1slot4.html">slot4</a>&amp; src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1slot4.html">slot4</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot4.html#ac2fb7f8ae312ced5b7436f0a0d062132">operator=</a> (const <a class="el" href="classsigc_1_1slot4.html">slot4</a>&amp; src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides this slot making a copy from another slot. <a href="#ac2fb7f8ae312ced5b7436f0a0d062132"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt;<br/>
 class sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</h3>

<p>Converts an arbitrary functor to a unified type which is opaque. </p>
<p><a class="el" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot</a> itself is a functor or to be more precise a closure. It contains a single, arbitrary functor (or closure) that is executed in <a class="el" href="classsigc_1_1slot4.html#a8d7a64f3e5c308136ea6456450d83f43" title="Invoke the contained functor unless slot is in blocking state.">operator()()</a>.</p>
<p>The template arguments determine the function signature of <a class="el" href="classsigc_1_1slot4.html#a8d7a64f3e5c308136ea6456450d83f43" title="Invoke the contained functor unless slot is in blocking state.">operator()()</a>:</p>
<ul>
<li><em>T_return</em> The return type of <a class="el" href="classsigc_1_1slot4.html#a8d7a64f3e5c308136ea6456450d83f43" title="Invoke the contained functor unless slot is in blocking state.">operator()()</a>.</li>
<li><em>T_arg1</em> Argument type used in the definition of <a class="el" href="classsigc_1_1slot4.html#a8d7a64f3e5c308136ea6456450d83f43" title="Invoke the contained functor unless slot is in blocking state.">operator()()</a>. The default <code>nil</code> means no argument.</li>
<li><em>T_arg2</em> Argument type used in the definition of <a class="el" href="classsigc_1_1slot4.html#a8d7a64f3e5c308136ea6456450d83f43" title="Invoke the contained functor unless slot is in blocking state.">operator()()</a>. The default <code>nil</code> means no argument.</li>
<li><em>T_arg3</em> Argument type used in the definition of <a class="el" href="classsigc_1_1slot4.html#a8d7a64f3e5c308136ea6456450d83f43" title="Invoke the contained functor unless slot is in blocking state.">operator()()</a>. The default <code>nil</code> means no argument.</li>
<li><em>T_arg4</em> Argument type used in the definition of <a class="el" href="classsigc_1_1slot4.html#a8d7a64f3e5c308136ea6456450d83f43" title="Invoke the contained functor unless slot is in blocking state.">operator()()</a>. The default <code>nil</code> means no argument.</li>
</ul>
<p>To use simply assign the slot to the desired functor. If the functor is not compatible with the parameter list defined with the template arguments compiler errors are triggered. When called the slot will invoke the functor with minimal copies. <a class="el" href="classsigc_1_1slot__base.html#a69042c2e2b0e5449fbf8203e862192a7" title="Sets the blocking state.">block()</a> and <a class="el" href="classsigc_1_1slot__base.html#ad93eaf25fae13186a1af8f699c6004a1" title="Unsets the blocking state.">unblock()</a> can be used to block the functor's invocation from <a class="el" href="classsigc_1_1slot4.html#a8d7a64f3e5c308136ea6456450d83f43" title="Invoke the contained functor unless slot is in blocking state.">operator()()</a> temporarily.</p>
<p>You should use the more convenient unnumbered <a class="el" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot</a> template. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae88657b620af0e8fa9b4855ecb4f0c20"></a><!-- doxytag: member="sigc::slot4::slot4" ref="ae88657b620af0e8fa9b4855ecb4f0c20" args="(const T_functor &amp;_A_func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
<div class="memtemplate">
template &lt;class T_functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1slot4.html">sigc::slot4</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt;::<a class="el" href="classsigc_1_1slot4.html">slot4</a> </td>
          <td>(</td>
          <td class="paramtype">const T_functor &amp;&#160;</td>
          <td class="paramname"> <em>_A_func</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a slot from an arbitrary functor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>The desired functor the new slot should be assigned to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8d7a64f3e5c308136ea6456450d83f43"></a><!-- doxytag: member="sigc::slot4::operator()" ref="a8d7a64f3e5c308136ea6456450d83f43" args="(arg1_type_ _A_a1, arg2_type_ _A_a2, arg3_type_ _A_a3, arg4_type_ _A_a4) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T_return <a class="el" href="classsigc_1_1slot4.html">sigc::slot4</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">arg1_type_&#160;</td>
          <td class="paramname"> <em>_A_a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg2_type_&#160;</td>
          <td class="paramname"> <em>_A_a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg3_type_&#160;</td>
          <td class="paramname"> <em>_A_a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg4_type_&#160;</td>
          <td class="paramname"> <em>_A_a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invoke the contained functor unless slot is in blocking state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_a1</td><td>Argument to be passed on to the functor. </td></tr>
    <tr><td class="paramname">_A_a2</td><td>Argument to be passed on to the functor. </td></tr>
    <tr><td class="paramname">_A_a3</td><td>Argument to be passed on to the functor. </td></tr>
    <tr><td class="paramname">_A_a4</td><td>Argument to be passed on to the functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return value of the functor invocation. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2fb7f8ae312ced5b7436f0a0d062132"></a><!-- doxytag: member="sigc::slot4::operator=" ref="ac2fb7f8ae312ced5b7436f0a0d062132" args="(const slot4 &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1slot4.html">slot4</a>&amp; <a class="el" href="classsigc_1_1slot4.html">sigc::slot4</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsigc_1_1slot4.html">slot4</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp;&#160;</td>
          <td class="paramname"> <em>src</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overrides this slot making a copy from another slot. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The slot from which to make a copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>this</code>. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Mar 8 2011 11:44:41 for libsigc++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
